#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 28 18:13:16 2018

@author: wanglab

Functions written by Tom Pisano (tpisano@princeton.edu, tjp77@gmail.com)

"""
import numpy as np, cv2, sys, multiprocessing as mp
import time
from skimage.external import tifffile

from scipy import ndimage
from scipy.ndimage.morphology import generate_binary_structure

def calculate_cell_measures(**params):
    
    #load reconstructed array
    reconstr_arr = np.lib.format.open_memmap(params["reconstr_arr"], dtype = params["dtype"], mode = "r")
    
    #find statistics 5 z planes at a time
    df = [] #initialise data frame
    for i in range(0, reconstr_arr.shape[0], 5):
        centers, sphericities = probabiltymap_to_centers_thresh(reconstr_arr[i:i+5,:,:], params["threshold"]) #threshold = (0.6, 1)            
        sys.stdout.write('\nfinished finding centers for planes # {}\n'.format((i+1)-(i+6))); sys.stdout.flush()
        intensities = find_intensity(centers, i, params["reconstr_arr"], zyx_search_range=(5,10,10))
        d = join_cell_statistics(centers, intensities, sphericities)
        df.append(d)
    

def join_cell_statistics(centers, intensities, sphericities):
    ''' joins multiple values for a predicted cell into a dataframe '''
    
    d = []

    for i, zyx in enumerate(centers): #i is the cell pixel value i.e. cell 0, cell 1, cell 2, cell 3
        d.append([int(zyx[0]),int(zyx[1]),int(zyx[2]), intensities[i], sphericities[i]])
               
    return d 


#%%
def probabiltymap_to_centers_thresh(src, threshold = (0.1,1), numZSlicesPerSplit = 5, overlapping_planes = 40, cores = 12, 
                                    return_pixels = False, verbose = False, structure_rank_order = 2):
    '''
    by tpisano
    
    Function to take probabilty maps generated by run_cnn and output centers based on center_of_mass

    Inputs:
    --------------
    memmapped_paths: (optional, str, or list of strs) pth(s) to memmapped array
    threshold: (tuple) lower and upper bounds to keep. e.g.: (0.1, 1) - note this assumes input from a CNN and thus data will
    numZSlicesPerSplit: chunk of zplanes to process at once. Adjust this and cores based on memory constraints.
    cores: number of parallel jobs to do at once. Adjust this and numZSlicesPerSplit based on memory constraints
    overlapping_planes: number of planes on each side to overlap by, this should be comfortably larger than the maximum z distances of a single object
    structure_rank_order: Optional. If true provides the structure element to used in ndimage.measurements.labels, 2 seems to be the most specific
    save (optional) 'True', 'False', str of path and file name to save with extension .p. If multiple cell /jukebox/LightSheetTransfer/cnn/zmd/20180929_395000chkpnt_xy160z20/channels.
    return_pixels, if True return centers and all pixels associated with that center

    Returns single list of
    ------------
    centers: list of zyx coordinates of centers of mass
    (IF RETURN PIXELS = True, dictionary consisting of k=centers, v=indices determined by cnn with k's center)
    save_location (if saving)

    OUTPUTS ZYX

    '''
    #handle inputs
    if type(src) == str:
        if src[-3:] == 'tif': src = tifffile.imread(src)
        if src[-3:] == 'npy': src = np.lib.format.open_memmap(src, dtype = 'float32', mode = 'r')

    zdim, ydim, xdim = src.shape

    #run
    if cores > 1: 
        start = time.time()
        if verbose: sys.stdout.write('\n   Thesholding, determining connected pixels, identifying center of masses\n\n')
        sys.stdout.flush()
        p = mp.Pool(cores)
        iterlst=[(src, z, numZSlicesPerSplit, overlapping_planes, threshold, return_pixels, structure_rank_order) for z in range(0, zdim, numZSlicesPerSplit)]
        centers = p.map(helper_labels_centerofmass_thresh, iterlst)
        p.terminate()
    else:
        start = time.time()
        if verbose: sys.stdout.write('\n   Thesholding, determining connected pixels, identifying center of masses\n\n'); sys.stdout.flush()
        iterlst=[(src, z, numZSlicesPerSplit, overlapping_planes, threshold, return_pixels, structure_rank_order) for z in range(0, zdim, numZSlicesPerSplit)]
        centers = []
        for i in iterlst: 
            centers.append(helper_labels_centerofmass_thresh(i))
        

    #unpack
    if not return_pixels: centers = [zz for xx in centers for zz in xx]
    if return_pixels:
        center_pixels_dct = {}; [center_pixels_dct.update(xx[1]) for xx in centers]
        centers = [zz for xx in centers for zz in xx[0]]
        
    if verbose: print ('Total time {} minutes'.format(round((time.time() - start) / 60)))
    if verbose: print('{} objects found.'.format(len(centers)))

    if return_pixels: return center_pixels_dct
    return centers


def helper_labels_centerofmass_thresh((array, start, numZSlicesPerSplit, overlapping_planes, threshold, return_pixels, structure_rank_order)):
    '''
    by tpisano
    
    '''
    zdim, ydim, xdim = array.shape

    structure = generate_binary_structure(array.ndim, structure_rank_order) if structure_rank_order else None

    #process
    if start == 0:
        arr = array[:numZSlicesPerSplit+overlapping_planes]
        #thresholding
        arr[arr<threshold[0]] = 0
        arr[arr>threshold[1]] = 0
        #find labels
        labels = ndimage.measurements.label(arr, structure); lbl_len = labels[1]
        centers = ndimage.measurements.center_of_mass(arr, labels[0], range(1, labels[1]+1)); 
        sphericity_values = get_sphericity(labels, centers, dims=3)
        #return pixels associated with a center
        if return_pixels: dct = return_pixels_associated_w_center(centers, labels)
        del labels, arr
        assert lbl_len == len(centers), 'Something went wrong, center of mass missed labels'
        #filter such that you only keep centers in first half
        centers = [center for center in centers if (center[0] <= numZSlicesPerSplit)]
        if return_pixels: dct = {c:dct[c] for c in centers}

    else: #cover 3x
        arr = array[start - overlapping_planes : np.min(((start + numZSlicesPerSplit + overlapping_planes), zdim))]
        #thresholding
        arr[arr<threshold[0]] = 0
        arr[arr>threshold[1]] = 0
        #find labels
        labels = ndimage.measurements.label(arr)
        centers = ndimage.measurements.center_of_mass(arr, labels[0], range(1, labels[1]))
        sphericity_values = get_sphericity(labels, centers, dims=3)

        #return pixels associated with a center
        if return_pixels: dct = return_pixels_associated_w_center(centers, labels)
        del labels, arr
        #filter such that you only keep centers within middle third
        centers = [center for center in centers if (center[0] > overlapping_planes) and (center[0] <= np.min(((numZSlicesPerSplit + overlapping_planes), zdim)))]
        if return_pixels: dct = {c:dct[c] for c in centers}
        
    #adjust z plane to accomodate chunking
    centers = [(xx[0]+start, xx[1], xx[2]) for xx in centers]
    if return_pixels: 
        dct = {tuple((kk[0]+start, kk[1], kk[2])):v for kk,v in dct.iteritems()}
        return centers, dct, sphericity_values

    return centers, sphericity_values


def return_pixels_associated_w_center(centers, labels, size = (15,100,100)):
    '''
    by tpisano
    
    Function to return dictionary of k=centers, v=pixels of a given label
    size is the search window from center - done to speed up computation
    ''' 
    dct = {}
    zz,yy,xx = size
    for cen in centers:
        z,y,x = [aa.astype('int') for aa in cen]
        dct[cen] = np.asarray(np.where(labels[0][z-zz:z+zz+1, y-yy:y+yy+1, x-xx:x+xx+1]==labels[0][z,y,x])).T    
    return dct

#%%
def sphericity(src, dims=3):
    '''src = 3d
    looks at it from two perspectives and then takes the total average
    dims=(2,3) number of dimensions to look at
    
    ball(9) = .895
    cube(9) = .785
    cylinder(9,9) = .770
    np.asarray([star(9) for xx in range(9)]) = .638
    
    sometime two contours are found on a zplane after labels - in this case take min, but could take average?
    '''
    lst = []; #src = np.copy(src).astype('uint8')
    if 0 in src.shape: return 0 #projects against empty labels
    for z in src:
        contours = findContours(z)
        circ = circularity(contours)
        if len(circ)>0: lst.append(np.min(circ))
    if dims==3:
        for z in np.swapaxes(src, 0,1):
            contours = findContours(z)
            circ = circularity(contours)
            if len(circ)>0: lst.append(np.min(circ))
    out = np.asarray(lst)
    if len(out)>0: 
        return np.mean(out)
    else:
        return 0

def circularity(contours):
    """
    A Hu moment invariant as a shape circularity measure, Zunic et al, 2010
    """
    #moments = [cv2.moments(c.astype(float)) for c in contours]
    #circ = np.array([(m['m00']**2)/(2*np.pi*(m['mu20']+m['mu02'])) if m['mu20'] or m['mu02'] else 0 for m in moments])
    circ = [ (4*np.pi*cv2.contourArea(c))/(cv2.arcLength(c,True)**2) for c in contours]

    return np.asarray(circ)

def findContours(z):
    '''Function to handle compatiblity of opencv2 vs 3
    '''
    if str(cv2.__version__)[0] == '3':
        cim,contours,hierarchy = cv2.findContours(z, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) #if need more than two values to unpack error here upgrade to cv2 3+
    elif str(cv2.__version__)[0] == '2':
        contours,hierarchy = cv2.findContours(z, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) #if need more than two values to unpack error here upgrade to cv2 3+
    contours = np.asarray([c.squeeze() for c in contours if cv2.contourArea(c)>0])
    return contours


def get_sphericity(labels, centers, dims=3, box_size=75):
    '''Function that takes in from scipy.ndimage.labels
    
    1 is more spherical
    dims=(2,3) number of dimensions to look at
    box_size: 1/2 size of bounding box (should be comfortably larger than cell). 50 = 50pixels +/- center, meaning a 100pixel length cube

    '''
    if labels[1]==0: #np array of zeros
        return labels
    else:
        vals = range(1, labels[1]+1) #don't need zero and account for zero indexing
        sphericity_values=[]
        for val,center in zip(vals, centers):
            try:
              sphericity_values.append(sphericity(bounding_box_from_center_array(labels[0], val, center, box_size=box_size), dims))
            except Exception,e:
              print e, val, 'Sphericity', dims
              raise Exception
        return np.asarray(sphericity_values)


def bounding_box_from_center_array(src, val, center, box_size=75):
    '''Faster version of _array as it makes a box rather than calculating
    '''
    z,y,x = [int(xx) for xx in center]
    out = np.copy(src[max(0,z-box_size):z+box_size, max(0,y-box_size):y+box_size, max(0,x-box_size):x+box_size]) #copy is critical
    out[out!=val]=0
    return out.astype('uint8')

    
def find_intensity(centers, start, recon_dst, zyx_search_range=(5,10,10)):
    '''
    function to return maximum intensity of a determined center src_raw given a zyx point and search range
    zyx_search_range=(4,10,10)
    zyx = (345, 3490, 3317)
    '''    
    #initialise
    a = []
    for i in centers:
        #setting the proper ranges
        z,y,x = i[0]+start,i[1],i[2]
        zr,yr,xr = zyx_search_range
        
        #making sure ranges are not negative
        rn = []
        for xx,yy in zip((z,y,x), zyx_search_range):
            if yy < xx:
                rn.append((xx-yy, xx+yy+1))
            else:
                rn.append((xx, xx+yy+1))
        
        #load reconstructed memmap array
        cnn_src = np.lib.format.open_memmap(recon_dst, dtype = 'float32', mode = 'r')
        
        #find part of cell 
        arr = cnn_src[rn[0][0]:rn[0][1], rn[1][0]:rn[1][1], rn[2][0]:rn[2][1]]
        
        #find the maximum
        mx = np.max(arr)
        
        #append the initialised list
        a.append(mx)
        
    return np.array(a)
     